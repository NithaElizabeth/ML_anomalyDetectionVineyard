<h1 align="center">JSON Formattings used in the application</h1>

<p align="center">
    We use JSON format for a number of purposes in this application. As a result, it is important to understand the structure used in each of these files so that we can change the settings later on. This document will serve as a central repository of documentation where we will explain the usage and format for each JSON file <i>(created and generated)</i>. All the JSON files will be stored in the <a href="https://github.com/software3daerospace/treecounter-ML/tree/main/data">data</a> directory.
</p>

---

## Table of Contents

1. [Default Configuration of the Application](#default-configuration-of-the-application)
    - [detector](#detector)
    - [tracker](#tracker)
    - [font](#font)
    - [Usage](#usage)

1. [Generated Detections from Input](#generated-detections-from-input)
    - [Details of the frame object](#details-of-the-frame-object)
    - [Reading from the JSON file](#reading-from-the-json-file)

---

## Default Configuration of the Application

The default configuration of the application are stored in the file `data/config.json`, unless otherwise specified. This file can be used in the application to define several starting conditions which are unlikely to change at run-time, such as the location of the model-specific files, the detector sensitivity, the tracker parameters, _etc_. We can take a closer look at this file to understand how the data is defined:

```json
{
    "detector": 
        {
            "config"    : "models/yolov4/yolov4-custom.cfg",
            "weights"   : "models/yolov4/yolov4-custom_final.weights",
            "labels"    : "models/yolov4/classes-3.names",
            "confidence": "0.75",
            "nms-thresh": "0.1"
        },
    "tracker": 
        {
            "max-age"   : "10",
            "min-hits"  : "10",
            "iou-thresh": "0.1"
        },
    "font": 
        {
            "style"    : "2",
            "scale"    : "0.5",
            "thickness": "1"
        }
}
```

As we can see, we have three main objects in this JSON file, the detector, the tracker, and the font. The detector is the most important object in this case, which contains certain key:value pairs that are important for the functionality of the application. They are defined in the following section.

### detector

- `config`    : Provides the path to the configuration _(.cfg)_ file of the YOLOv4 network
- `weights`   : Provides the path to the weights _(.weights)_ file of the YOLOv4 network
- `labels`    : Provides the path to the labels _(.names)_ file of the YOLOv4 network
- `confidence`: Sets the confidence level _(Only show detections beyond this threshold)_ for the detector
- `nms-thresh`: Sets the threshold for performing the non-minimum suppression to filter the detections 

### tracker

- `max-age`   : Sets the max_age parameter for the SORT tracker. Tracks an object for at least max_age number of frames. 
- `min-hits`  : Sets the min_hits parameter for the SORT tracker. If min_hits frames have passed since the last tracking of the object, the track of the object is assumed to be lost. 
- `iou-thresh`: Sets the iou_thresh parameter for the SORT tracker. Associates the track only if the IoU overlap is beyond iou_thresh.

### font

- `style`   : Corresponds to the option `CV2.FONT_HERSHEY_DUPLEX`. Check the [OpenCV enum declaration](https://docs.opencv.org/master/d6/d6e/group__imgproc__draw.html) for Hershey Fonts for more.

- `scale`    : Corresponds to the fontScale parameter in the `cv2.putText()` function.
- `thickness`: Corresponds to the line thickness setting in any OpenCV drawing application.

### Usage

Importing the configuration is fairly straightforward. We can simply use the `json` module in python to parse the _config.json_ file and since each of the entries are ordered, we can access a particular setting quite easily, as shown in the example below:

```python
# Import settings from the config.json file

import json

def foobar():

    # open the file and load all its contents
    with open('data/config.json', 'r') as f:
        config_params = json.load(f)

    # Load the YOLOv4 detector with given config and weights
    net = cv2.dnn.readNetFromDarknet(config_params["detector"]["config"],
                                     config_params["detector"]["weights"])                 

    .
    .
    .
    # similarly, we can access the other parameters

    return True

if __name__=='__main__':
    foobar() 
    
```

---

## Generated Detections from Input

The object tracks that are generated by running the application `track_video.py` are also stored in the json format in the file `data/detections.json`. The formatting of the objects are in a key:value fashion, where the key is the frame number and the value is an array of all the tracks found in that frame. Each element in this array is again stored in a similar key:value pair, having multiple attributes.

The top-level architecture of how the json is represented can be seen in the figure below:

<p align="center">
    <img src="https://github.com/software3daerospace/treecounter-ML/blob/fix-tracks/docs/imgs/json-diag.png" alt="Pictorial Representation of the JSON format">
</p>

### Details of the frame object

The organisation of each frame object is as follows:

- id : The tracking ID assigned to the object
- class : The class of the detected object
- direction: The direction the detected object is in _(this is used for missing tree calculations)_ 
- centroid : The centroid of the bounding box around the object _(pixel co-ordinate system)_
- bbox : The location of the bounding box around the object in `x1, y1, x2, y2` format.

Please note that future updates to this might include the co-ordinates of the detected object in the world frame as well.

### Reading from the JSON file

Because it has a somewhat nested structure, it can sometimes be difficult to understand how to read from the file. The below piece of code may be used to read from the detections.json file:

```python
import json
import numpy as np

detections = []

# Load the json file
with open('data/detections.json', 'r') as f:
    detections = json.load(f)

# Loop through the first 20 objects in the array
for i in range(0, 20):
    
    this_objs = detections[i]["frame {}".format(i)]

    # This gives us a list of python dictionary objects 
    # We can now loop through this list to extract each
    #individual object
    for obj in this_objs:
        print(obj)
    
```
---